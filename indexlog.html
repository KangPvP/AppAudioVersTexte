<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Speech to Text - Logger</title>
    <style>
        :root {
            --primary-color: #4285f4;
            --bg-color: #f4f6f8;
            --card-bg: #ffffff;
        }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; padding: 20px; max-width: 900px; margin: 0 auto; background-color: var(--bg-color); }
        
        /* Zone de commande principale */
        .main-controls { background: var(--card-bg); padding: 25px; border-radius: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 30px; }
        
        button { padding: 12px 24px; cursor: pointer; background-color: var(--primary-color); color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: bold; transition: background 0.3s; }
        button:hover { background-color: #3367d6; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        
        .status { margin-top: 15px; color: #555; font-size: 0.9em; }
        .error { color: #d93025; }

        /* Styles pour la zone des LOGS */
        #logsContainer { display: flex; flex-direction: column; gap: 20px; }
        
        .log-entry {
            background: var(--card-bg);
            border-left: 5px solid var(--primary-color);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            animation: slideIn 0.5s ease-out;
        }

        .log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .log-date { font-weight: bold; color: #555; font-size: 0.9em; }
        .log-badge { background: #e8f0fe; color: var(--primary-color); padding: 4px 8px; border-radius: 4px; font-size: 0.8em; font-weight: bold; }

        .log-body { display: flex; flex-direction: column; gap: 15px; }
        
        /* Lecteur audio personnalis√© */
        audio { width: 100%; height: 40px; }
        
        .log-text {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 6px;
            white-space: pre-wrap; /* Garde les retours √† la ligne */
            font-size: 1.05em;
            line-height: 1.5;
            color: #333;
            border: 1px solid #eee;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>

<div class="main-controls">
    <h2>üéôÔ∏è Transcripteur Audio & Logs</h2>
    <p>S√©lectionnez un fichier (MP3, M4A, WAV...) pour le transcrire et l'archiver ci-dessous.</p>
    
    <input type="file" id="audioInput" accept="audio/*">
    <br><br>
    <button id="sendBtn">Lancer la transcription</button>
    <div id="status" class="status"></div>
</div>

<h3>Historique des Transcriptions</h3>
<div id="logsContainer">
    <div style="text-align: center; color: #aaa; font-style: italic;" id="emptyMsg">Aucun enregistrement pour le moment.</div>
</div>

<script>
    // ‚ö†Ô∏è REMPLACEZ PAR VOTRE CL√â API GOOGLE
    const API_KEY = 'AIzaSyDvhEEI4Nb7yo1b1RRwitaU9Y7JpgguTUY'; 

    const statusDiv = document.getElementById('status');
    const logsContainer = document.getElementById('logsContainer');
    const emptyMsg = document.getElementById('emptyMsg');

    document.getElementById('sendBtn').addEventListener('click', async () => {
        const inputElement = document.getElementById('audioInput');
        if (inputElement.files.length === 0) return alert("Veuillez s√©lectionner un fichier.");
        
        const file = inputElement.files[0];
        const btn = document.getElementById('sendBtn');

        // UI Update
        btn.disabled = true;
        statusDiv.textContent = "‚è≥ Traitement en cours (Conversion & Envoi)...";
        statusDiv.className = "status";

        try {
            // 1. Conversion Audio (Moteur universel)
            const audioData = await convertFileToWavBase64(file);

            // 2. Requ√™te Google
            const payload = {
                config: {
                    encoding: "LINEAR16",
                    sampleRateHertz: audioData.sampleRate,
                    languageCode: "fr-FR",
                    enableAutomaticPunctuation: true
                },
                audio: { content: audioData.base64 }
            };

            const response = await fetch(`https://speech.googleapis.com/v1/speech:recognize?key=${API_KEY}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const data = await response.json();

            if (data.error) throw new Error(data.error.message);

            // 3. R√©cup√©ration du texte
            let finalTranscript = "(Audio vide ou non reconnu)";
            if (data.results) {
                finalTranscript = data.results
                    .map(r => r.alternatives[0].transcript)
                    .join('\n');
            }

            // 4. CR√âATION DU LOG (C'est ici que la magie op√®re)
            addLogEntry(file, finalTranscript);
            
            statusDiv.textContent = "‚úÖ Transcription termin√©e et ajout√©e aux logs.";

        } catch (error) {
            console.error(error);
            statusDiv.textContent = "‚ùå Erreur : " + error.message;
            statusDiv.className = "status error";
        } finally {
            btn.disabled = false;
            inputElement.value = ""; // Reset input pour permettre de remettre le m√™me fichier
        }
    });

    // ==========================================
    // FONCTION DE GESTION DES LOGS (UI)
    // ==========================================
    function addLogEntry(originalFile, transcriptText) {
        // Supprimer le message "vide" si c'est le premier log
        if (emptyMsg) emptyMsg.style.display = 'none';

        // Cr√©er l'URL temporaire pour jouer le fichier original
        const audioUrl = URL.createObjectURL(originalFile);
        const timestamp = new Date().toLocaleString('fr-FR', { 
            day: '2-digit', month: '2-digit', year: 'numeric', 
            hour: '2-digit', minute: '2-digit', second: '2-digit' 
        });

        // Cr√©ation de l'√©l√©ment HTML
        const logEntry = document.createElement('div');
        logEntry.className = 'log-entry';
        
        logEntry.innerHTML = `
            <div class="log-header">
                <span class="log-date">üìÖ ${timestamp}</span>
                <span class="log-badge">Fichier: ${originalFile.name}</span>
            </div>
            <div class="log-body">
                <audio controls src="${audioUrl}"></audio>
                <div class="log-text">${transcriptText}</div>
            </div>
        `;

        // Insertion au D√âBUT de la liste (prepend) pour l'ordre d√©chronologique
        logsContainer.prepend(logEntry);
    }

    // ==========================================
    // MOTEUR DE CONVERSION AUDIO (Idem pr√©c√©dent)
    // ==========================================
    async function convertFileToWavBase64(file) {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        try {
            const arrayBuffer = await file.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            const wavBlob = bufferToWav(audioBuffer);
            const base64 = await blobToBase64(wavBlob);
            return { base64: base64, sampleRate: audioBuffer.sampleRate };
        } finally {
            if (audioContext.state !== 'closed') audioContext.close();
        }
    }

    function blobToBase64(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(blob);
            reader.onload = () => resolve(reader.result.split(',')[1]);
            reader.onerror = reject;
        });
    }

    function bufferToWav(abuffer) {
        const numOfChan = abuffer.numberOfChannels;
        const length = abuffer.length * numOfChan * 2 + 44;
        const buffer = new ArrayBuffer(length);
        const view = new DataView(buffer);
        let pos = 0;

        function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }
        function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }

        setUint32(0x46464952); // RIFF
        setUint32(length - 8);
        setUint32(0x45564157); // WAVE
        setUint32(0x20746d66); // fmt 
        setUint32(16);
        setUint16(1);
        setUint16(numOfChan);
        setUint32(abuffer.sampleRate);
        setUint32(abuffer.sampleRate * 2 * numOfChan);
        setUint16(numOfChan * 2);
        setUint16(16);
        setUint32(0x61746164); // data
        setUint32(length - pos - 4);

        const channels = [];
        for(let i = 0; i < numOfChan; i++) channels.push(abuffer.getChannelData(i));

        let offset = 0;
        while(pos < length) {
            for(let i = 0; i < numOfChan; i++) {
                let sample = Math.max(-1, Math.min(1, channels[i][offset]));
                sample = (sample < 0 ? sample * 0x8000 : sample * 0x7FFF) | 0;
                view.setInt16(pos, sample, true);
                pos += 2;
            }
            offset++;
        }
        return new Blob([buffer], { type: "audio/wav" });
    }
</script>

</body>
</html>